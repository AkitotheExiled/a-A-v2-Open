// All about Scope in JavaScript

/*

Scope is a set of variables availble for use within the program.

Any variable/expression not in scope?  we can't use it :(


    1. Security - Variables can only be access by pre-defined parts of our program.
    2. Reduced variable name collisions - Using same variable name in different scopes prevent namespace collisions

*/


// Different kinds of scope

// global scope, local scope, block scope

// Global scope

/*

Represented by window object in browser

and global object in Node.js

*/

let myName = "Mike";

console.log(myName);

// myName is part of our global scope
// TRY AVOIDING GLOBAL VARIABLES TO PREVENT VARIABLE OVERWRITES



// local scope
/*

set of variables that are available to use within functions.

Local Scope includes:

1. functions arguments
2. any local variables declared inside function
3. any variables that were already defined when the function was declared

*/

// global scope
let myName2 = "global";

function function1() {
  // function1's scope
  let myName2 = "func1";
  console.log("function1 myName: " + myName2);
}

function function2() {
  // function2's scope
  let myName2 = "func2";
  console.log("function2 myName: " + myName2);
}

function1(); // function1 myName: func1
function2(); // function2 myName: func2
console.log("global myName: " + myName2); // global myName: global



// Block scope
/*

defined by { } -> if , for, while loops

when we use let or const variables within curly braces they will be block scoped.

*/

let cat = "meow";

if (true) {
    let cat = "BARK";
    console.log(cat);
}

console.log(cat);

// Scope chaining: variables and scope

// inner scope has access to variables in the outer scope

let name = "Soxabathu";

function hungryKitty() {
    console.log(name + " is hungry!");
}

hungryKitty();

/*

So when the hungryHippo function is declared a new local scope will be created for that function.
Continuing on that line of thought what happens when we refer to name inside of hungryHippo?
If the name variable is not found in the immediate scope,
JavaScript will search all of the accessible outer scopes until it finds a variable name that matches the one we are referencing.
 Once it finds the first matching variable, it will stop searching. In JavaScript this is called scope chaining.

 */

 // global scope
let person = "Rae";

// sayHello function's local scope
function sayHello() {
  let person = "Jeff";

  // greet function's local scope
  function greet() {
    console.log("Hi, " + person + "!");
  }
  greet();
}

sayHello(); // logs 'Hi, Jeff!'


// OUTER SCOPE CANNOT REFERENCE INNER VARIABLES





// Lexical Scope

// JS code is parsed before it is ran
// Resolves values of variables without running code

function outer() {
    let x = 5;
    let x = 3;
    function inner() {
      // here we know the value of x because scope chaining will
      // go into the scope above this one looking for variable named x.
      // We do not need to run this code in order to determine the value of x!
      console.log(x);
    }
    inner();
  }





  // Arrow Functions

  /*

  1. Define an arrow function
  2. Use implicit return with an arrow function

  */

  // function declaration
let average = function(num1, num2) {
    let avg = (num1 + num2) / 2;
    return avg;
  };

  // fat arrow function style!
  let averageArrow = (num1, num2) => {
    let avg = (num1 + num2) / 2;
    return avg;
  };


  /* Anatomy of arrow functions

  (parameters, go, here) => {
  statement1;
  statement2;
  return a value;
}

*/

// Single Expression Arrow Functions

// do not need to explicitly state return!
const arrowMultiply = (num1, num2) => num1 * num2;


// Syntactic ambiguity with arrow functions

const ambigous = () => {};

ambigous(); // // => undefined

/*

Is ambiguousFunction supposed to return an empty object or an empty code block?
Confusing right?
JavaScript standards state that the curly braces after a fat arrow evaluate to an empty block (which has the default value of undefined):

*/

// this will implicitly return an empty object
const clearFunction = () => ({});
clearFunction(); // returns an object: {}
